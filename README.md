# 了不起的Node js 将JavaScript进行到底

#### PART Ⅰ　从安装与概念开始
- CHAPTER 1 安装
  - 在window下安装
  - 在OS X下安装
  - 在Linux下安装
    - 编译
    - 确保安装成功
  - Node REPL
  - 执行文件
    - 安装模块
    - 自定义模块
    - 安装二进制包
    - 浏览NPM仓库
  - 小结
  
- CHAPTER 2 JavaScript概览
  - 介绍
  - JavaScript基础
    - 类型
    - 类型的困惑
    - 函数
    - THIS、FUNCTION#CALL以及FUNCTION#APPLY
    - 函数的参数
    - 闭包
    - 类
    - 继承
    - TRY {} CATCH {}
  - v8中的JavaScript
    - OBJECT#KEYS
    - ARRAY#ISARRAY
    - 数组方法
    - 字符串方法
    - JSON
    - FUNCTION#BIND
    - FUNCTION#NAME
    - _PROTO_（继承）
    - 存取器
  - 小结
- CHAPTER 2 阻塞与非阻塞IO
  - 能力越强，责任就越大
    - 阻塞
      - Node.js使用事件轮询，是非阻塞的
        - 采用事件轮询意味着什么呢？从本质上来说，Node会先注册事件，随后不停地询问内核这些事件是否已分发。当事件分发时，对应的回调函数就会被触发，
  然后继续执行下去。如果没有事件触发，则继续执行其他代码，直到有新的事件时，再去执行对应的回调函数。
        - Node并发实现也采用了事件轮询。与timeout所采用的技术一样，所有像http、net这样的原生模块中的IO部分也都采用了事件轮询技术。和timeout机制
        中Node内部会不停地等待，并当超时完成时，触发一个消息通知一样，Node使用事件轮询，触发一个和文件描述符相关的通知。
        - 文件描述符是抽象的句柄，存有对打开的文件、socket、管道等的引用。本质上来说，当Node接收到浏览器发来的HTTP请求时，底层的TCP连接会分配一个
        文件描述符。随后，如果客户端向服务器发送数据，Node就会收到该文件描述符上的通知，然后出发JavaScript的回调函数。
    - 单线程的世界
    - 错误处理
    - 堆栈追踪
  - 小结
- CHAPTER 4　Node中的JavaScript
  - global对象
    - 实用的全局对象
  - 模块系统
    - 绝对和相对模块
  - 暴露API
  - 事件
  - buffer
  - 小结
#### PART Ⅱ　Node重要的API
- CHAPTER 5　命令行工具（CLI）以及FS API：首个Node应用
  - 需求
  - 编写首个Node程序
    - 创建模块
    - 同步还是异步
    - 理解什么是流（stream）
    - 输入和输出
    - 重构
    - 用fs进行文件操作
  - 对CLI一探究竟
    - argv
    - 工作目录
    - 环境变量
    - 退出
    - 信号
    - ANSI转义码
  - 对fs一探究竟
    - Stream
    - 监视
  - 小结
- CHAPTER 6　TCP
  - TCP有哪些特性
    - 面向连接的通信和保证顺序的传递
    - 面向字节
    - 可靠性
    - 流控制
    - 拥堵控制
  - Telnet
  - 基于TCP的聊天程序
    - 创建模块
    - 理解NET.SERVER.API
    - 接收连接
    - data事件
    - 状态以及记录连接情况
    - 圆满完成此程序
  - 一个IRC客户端程序
    - 创建模块
    - 理解NET#STREAM.API
    - 实现部分IRC协议
    - 测试实际的IRC服务器
  - 小结
- CHAPTER 7　HTTP
  - HTTP结构
  - 头信息
  - 连接
  - 一个简单的Web服务器
    - 创建模块
    - 输出表单
    - method和URL
    - 数据
    - 整合
    - 让程序更健壮
  - 一个Twitter.Web客户端
    - 创建模块
    - 发送一个简单的HTTP请求
    - 发送数据
    - 获取推文
  - superagent来拯救
  - 使用up重启HTTP服务器
  - 小结
#### PART Ⅲ　Web开发
- CHAPTER 8　Connect
  - 使用HTTP构建一个简单的网站
  - 通过Connect实现一个简单的网站
  - 中间件
    - 书写可重用的中间件
    - static中间件
    - query中间件
  - logger中间件
    - body.parser中间件
    - cookie
    - 会话（session）
    - Redis.session
    - methodOverride中间件
    - basicAuth中间件
  - 小结
- CHAPTER 9　Express
  - 一个小型Express应用
    - 创建模块
    - HTML
    - SETUP
    - 定义路由
    - 查询
    - 运行
  - 设置
  - 模板引擎
  - 错误处理
  - 快捷方法
  - 路由
  - 中间件
  - 代码组织策略
  - 小结
- CHAPTER 10　WebSocket
  - Ajax
  - HTML5.WebSocket
  - 一个ECHO示例
    - 初始化项目
    - 建立服务器
    - 建立客户端
    - 运行示例程序
  - 鼠标光标
    - 初始化示例程序
    - 建立服务器
    - 建立客户端
    - 运行示例程序
  - 面临一个挑战
    - 关闭并不意味着断开连接
    - JSON
    - 重连
    - 广播
    - WebSocket属于HTML5：早期浏览器不支持
    - 解决方案
  - 小结 
- CHAPTER 11　Socket.IO
  - 传输 
    - 断开.VS.关闭
    - 事件
    - 命名空间
  - 聊天程序 
    - 初始化程序
    - 构建服务器
    - 构建客户端
    - 事件和广播
    - 消息接收确认
  - 一个轮流做DJ的应用 
    - 扩展聊天应用
    - 集成Grooveshark.API
    - 播放歌曲
  - 小结 
#### PART Ⅳ　数据库
- CHAPTER 12　MongoDB
  - 安装
  - 使用MongoDB：一个用户认证的例子
    - 构建应用程序
    - 创建Express.App
    - 连接MongoDB
    - 创建文档
    - 查找文档
    - 身份验证中间件
    - 校验
    - 原子性
    - 安全模式
  - Mongoose介绍
    - 定义模型
    - 定义嵌套的键
    - 定义嵌套文档
    - 构建索引
    - 中间件
    - 探测模型状态
    - 查询
    - 扩展查询
    - 排序
    - 选择
    - 限制
    - 跳过
    - 自动产生键
    - 转换
  - 一个使用Mongoose的例子
    - 构建应用
    - 重构
    - 建立模型
  - 小结
- CHAPTER 13　MySQL
  - node-mysql
    - 初始化项目
    - Express应用
    - 连接MySQL
    - 初始化脚本
    - 创建数据
    - 获取数据
  - sequelize
    - 初始化sequelize
    - 初始化Express应用
    - 连接sequelize
    - 定义模型和同步
    - 创建数据
    - 获取数据
    - 删除数据
    - 完整地完成应用
  - 小结
- CHAPTER 14　Redis
  - 安装Redis
  - Redis查询语言
  - 数据类型
    - 字符串
    - 哈希
    - 列表
    - 数据集
    - 有序数据集
  - Redis和Node
    - 使用node-redis实现一个社交图谱
  - 小结
#### PART Ⅴ　测试
- CHAPTER 15　代码共享
  - 什么样的代码可以共享
  - 书写兼容的JavaScript代码
    - 导出模块
    - 模拟实现ECMA.API
    - 模拟实现Node.API
    - 模拟实现浏览器端API
    - 跨浏览器的继承实现
  - 集成到一起：browserbuild
    - 基础案例
  - 小结
- CHAPTER 16　测试
  - 简单测试
    - 测试目标
    - 测试策略
    - 测试程序
  - expect.js
  - API一览
  - Mocha
    - 测试异步代码
    - BDD风格
    - TDD风格
    - export风格
    - 在浏览器端使用Mocha
  - 小结
